{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import fossilDelta from 'fossil-delta';\nimport msgpack from 'notepack.io';\n\nimport { Client, Protocol, Serializer, debugPatch } from '@colyseus/core';\nimport jsonPatch from 'fast-json-patch'; // this is only used for debugging patches\n\nexport class FossilDeltaSerializer<T> implements Serializer<T> {\n  public id = 'fossil-delta';\n\n  // when a new user connects, it receives the 'previousState', which holds\n  // the last binary snapshot other users already have, therefore the patches\n  // that follow will be the same for all clients.\n  private previousState: T;\n  private previousStateEncoded: any;\n\n  private patches: any;\n\n  public reset(newState: T) {\n    this.previousState = newState;\n    this.previousStateEncoded = msgpack.encode(this.previousState);\n  }\n\n  public getFullState(_?: Client) {\n    return this.previousStateEncoded;\n  }\n\n  public applyPatches(clients: Client[], previousState: T) {\n    const hasChanged = this.hasChanged(previousState);\n\n    if (hasChanged) {\n      this.patches.unshift(Protocol.ROOM_STATE_PATCH);\n\n      let numClients = clients.length;\n\n      while (numClients--) {\n        const client = clients[numClients];\n        client.enqueueRaw(this.patches);\n      }\n    }\n\n    return hasChanged;\n  }\n\n  public hasChanged(newState: T) {\n    const currentState = newState;\n    let changed: boolean = false;\n    let currentStateEncoded;\n\n    /**\n     * allow optimized state changes when using `Schema` class.\n     */\n    if (newState?.['$changes']) {// tslint:disable-line\n      if (newState['$changes'].changes.size > 0) { // tslint:disable-line\n        changed = true;\n        currentStateEncoded = msgpack.encode(currentState);\n      }\n\n    } else {\n      currentStateEncoded = msgpack.encode(currentState);\n      changed = !currentStateEncoded.equals(this.previousStateEncoded);\n    }\n\n    if (changed) {\n      this.patches = fossilDelta.create(this.previousStateEncoded, currentStateEncoded);\n\n      //\n      // debugging\n      //\n      if (debugPatch.enabled) {\n        debugPatch(\n          '%d bytes, %j',\n          this.patches.length,\n          jsonPatch.compare(msgpack.decode(this.previousStateEncoded), currentState),\n        );\n      }\n\n      this.previousState = currentState;\n      this.previousStateEncoded = currentStateEncoded;\n    }\n\n    return changed;\n  }\n\n}\n"],"names":[],"mappings":";;;;;MAMa,qBAAqB;IACzB,EAAE,GAAG,cAAc,CAAC;;;;IAKnB,aAAa,CAAI;IACjB,oBAAoB,CAAM;IAE1B,OAAO,CAAM;IAEd,KAAK,CAAC,QAAW;QACtB,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;KAChE;IAEM,YAAY,CAAC,CAAU;QAC5B,OAAO,IAAI,CAAC,oBAAoB,CAAC;KAClC;IAEM,YAAY,CAAC,OAAiB,EAAE,aAAgB;QACrD,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;QAElD,IAAI,UAAU,EAAE;YACd,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;YAEhD,IAAI,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;YAEhC,OAAO,UAAU,EAAE,EAAE;gBACnB,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;gBACnC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACjC;SACF;QAED,OAAO,UAAU,CAAC;KACnB;IAEM,UAAU,CAAC,QAAW;QAC3B,MAAM,YAAY,GAAG,QAAQ,CAAC;QAC9B,IAAI,OAAO,GAAY,KAAK,CAAC;QAC7B,IAAI,mBAAmB,CAAC;;;;QAKxB,IAAI,QAAQ,GAAG,UAAU,CAAC,EAAE;YAC1B,IAAI,QAAQ,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;gBACzC,OAAO,GAAG,IAAI,CAAC;gBACf,mBAAmB,GAAG,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;aACpD;SAEF;aAAM;YACL,mBAAmB,GAAG,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YACnD,OAAO,GAAG,CAAC,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;SAClE;QAED,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,EAAE,mBAAmB,CAAC,CAAC;;;;YAKlF,IAAI,UAAU,CAAC,OAAO,EAAE;gBACtB,UAAU,CACR,cAAc,EACd,IAAI,CAAC,OAAO,CAAC,MAAM,EACnB,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE,YAAY,CAAC,CAC3E,CAAC;aACH;YAED,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;YAClC,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC;SACjD;QAED,OAAO,OAAO,CAAC;KAChB;;;;;"}